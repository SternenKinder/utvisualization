# HOW TO BUILD (A) APPLICATION FROM A MODULE
# Building libraries from modules should be consistent for each module.
# Use the following scheme for each new library created:
#
# a) Check for required libraries. If they are not available return False and export flags if needed
# b) Define the src-subdirectories for which the library should be compiled
#    and glob all files in there
# c) Define a [LIBRARY]_options variable for the library containing all dependencies
#    from other libraries. Create a clone from the master environment and add those options.
# d) Build the application!
# e) Optionally setup help and ide projects
#
# The use of options and possibility to export them makes hierarchical build environments
# obsolete. Avoid exporting new environments to the build system.

import os

have_utfacade = False

Import( '*' )

# a)
if not have_utfacade:
	result = False
	Return('result')
	
# b)
sources = [ 'console.cpp' ]

# c)
config_options = mergeOptions( utfacade_all_options)

env = masterEnv.Clone()
env.AppendUnique( **config_options )
env.AppendUnique( LIBS = boost_libs( [ 'program_options' ] ) )

# fix library search paths on gnu linker
if 'gnulink' in env[ 'TOOLS' ]:
	boost_rpath = map( lambda x: Dir( x ).abspath, boost_options[ 'LIBPATH' ] )
	env.Append( RPATH = boost_rpath + [ env.Literal( "'$$ORIGIN/../lib'" ) ] )

# d)
# build the application
# {buildenvironment, source files, name of the application, build target}
setupAppBuild(env, sources, 'utConsole', 'facade')

# e)
createVisualStudioProject(env, sources, [], 'utFacade-Console')

